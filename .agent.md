# Bookstore Project - Developer Guide

## Project Overview

This is a Java-based online bookstore management system that demonstrates core software engineering concepts including:
- **Language**: Java 21
- **Build Tool**: Gradle 8.8 with Kotlin DSL
- **Database**: MySQL (JDBC connectivity)
- **Architecture**: Layered architecture with DAO pattern
- **Key Features**: Order processing, inventory management, search algorithms

## Project Structure

### Core Directories
- `app/src/main/java/com/bookstore/` - Main application source code
  - `main/` - Application entry point
  - `model/` - Domain entities (Book, Customer, Order, OrderItem, OrderStatus)
  - `dao/` - Data Access Objects for database operations
  - `service/` - Business logic layer (OrderService, OrderProcessingQueue)
  - `util/` - Utility classes including database connection and algorithms
- `gradle/` - Gradle configuration and version catalog
- `.vscode/` - VS Code IDE settings

### Key Files
- `settings.gradle.kts` - Project configuration (root project name: "Bookstore")
- `app/build.gradle.kts` - Application dependencies and build configuration
- `gradle/libs.versions.toml` - Centralized dependency version management
- `app/src/main/java/com/bookstore/main/Main.java` - Application entry point

## Dependencies and Technologies

### Core Dependencies
- **Guava 33.0.0-jre** - Google's core libraries for Java
- **MySQL Connector 8.0.33** - JDBC driver for MySQL database
- **JUnit Jupiter 5.10.2** - Testing framework

### Database Configuration
- **Database**: `online_bookstore_db` on localhost:3306
- **Default Credentials**: root/12345678 (configured in `DBConnection.java`)
- **Connection**: JDBC with MySQL Connector/J driver

## Architecture Patterns

### Layered Architecture
- **Presentation Layer**: Main class with console-based interaction
- **Service Layer**: Business logic (OrderService)
- **Data Access Layer**: DAO pattern for database operations
- **Model Layer**: Plain Java objects (POJOs) for domain entities

### Design Patterns Used
- **DAO Pattern**: Separate data access logic from business logic
- **Queue Pattern**: OrderProcessingQueue for asynchronous order processing
- **Strategy Pattern**: Comparators for different sorting strategies

## Development Best Practices

### Code Organization
- Use package-by-feature organization under `com.bookstore`
- Separate concerns with distinct layers (model, dao, service, util)
- Follow Java naming conventions (PascalCase for classes, camelCase for methods/variables)

### Database Operations
- Use PreparedStatement for all SQL operations to prevent SQL injection
- Handle SQLException appropriately with meaningful error messages
- Use try-with-resources for automatic resource management
- Check for specific MySQL error codes (1062 for duplicates, 1451 for foreign key constraints)

### Error Handling
- Catch and handle specific exceptions (SQLException, ClassNotFoundException)
- Provide meaningful error messages to users
- Use proper logging instead of System.out.println in production code
- Validate input parameters before database operations

### Algorithm Implementation
- Custom sorting algorithms in `util/algorithms/SortingAlgorithms.java`
- Binary search implementation in `util/algorithms/SearchingAlgorithms.java`
- Use Comparator pattern for flexible sorting strategies

## Build and Development

### Gradle Commands
```bash
./gradlew build          # Build the project
./gradlew run            # Run the application
./gradlew test           # Run tests
./gradlew clean          # Clean build artifacts
```

### IDE Configuration
- VS Code settings configured for automatic Java build configuration updates
- Java toolchain set to version 21
- Main class: `com.bookstore.main.Main`

## Database Setup Requirements

### Prerequisites
- MySQL server running on localhost:3306
- Database named `online_bookstore_db` must exist
- Required tables: Books, Customers, Orders, OrderItems
- Default credentials: root/12345678 (update in DBConnection.java as needed)

### Database Schema Considerations
- Books table with auto-increment book_id primary key
- Foreign key relationships between Orders and Customers
- Foreign key relationships between OrderItems and Books/Orders
- Stock quantity tracking in Books table

## Testing and Quality

### Testing Strategy
- JUnit Jupiter for unit testing
- Test database operations with proper setup/teardown
- Test business logic in service layer
- Test algorithm implementations separately

### Code Quality Guidelines
- Follow Java coding standards
- Use meaningful variable and method names
- Add proper JavaDoc comments for public APIs
- Handle edge cases (null checks, empty collections)
- Validate business rules (stock quantity, order totals)

## Common Development Tasks

### Adding New Features
1. Create model classes in `model/` package
2. Implement DAO classes for database operations
3. Add business logic in `service/` package
4. Update Main class to demonstrate new functionality
5. Add appropriate tests

### Database Schema Changes
1. Update SQL scripts for table modifications
2. Modify corresponding model classes
3. Update DAO methods for new fields
4. Test with existing data migration

### Algorithm Integration
1. Add new algorithms to `util/algorithms/` package
2. Create appropriate comparators for sorting
3. Integrate with service layer business logic
4. Add performance tests for large datasets

## Security Considerations

### Database Security
- **CRITICAL**: Change default database credentials in production
- Use environment variables or configuration files for sensitive data
- Implement proper connection pooling for production use
- Consider using prepared statements exclusively

### Input Validation
- Validate all user inputs before database operations
- Sanitize string inputs to prevent injection attacks
- Implement proper bounds checking for numeric inputs
- Use parameterized queries consistently

## Performance Considerations

### Database Performance
- Consider adding database indexes for frequently queried fields
- Implement connection pooling for better resource management
- Use batch operations for bulk inserts/updates
- Monitor query performance and optimize as needed

### Algorithm Performance
- Binary search requires sorted data - ensure proper sorting
- Consider caching frequently accessed data
- Profile algorithm performance with large datasets
- Use appropriate data structures for different use cases