# Bookstore Project - Developer Guide

## Project Overview

This is a Java-based online bookstore management system that demonstrates core software engineering concepts including:
- **Language**: Java 21
- **Build Tool**: Gradle 8.8 with Kotlin DSL
- **Database**: MySQL (JDBC connectivity)
- **Web Framework**: Spring Boot 3.2.0 with Thymeleaf templates
- **Architecture**: Layered architecture with DAO pattern + Web layer
- **Key Features**: Order processing, inventory management, search algorithms, web UI

## Project Structure

### Core Directories
- `app/src/main/java/com/bookstore/` - Main application source code
  - `main/` - Application entry point
  - `model/` - Domain entities (Book, Customer, Order, OrderItem, OrderStatus)
  - `dao/` - Data Access Objects for database operations
  - `service/` - Business logic layer (OrderService, OrderProcessingQueue)
  - `util/` - Utility classes including database connection and algorithms
- `gradle/` - Gradle configuration and version catalog
- `.vscode/` - VS Code IDE settings

### Key Files
- `settings.gradle.kts` - Project configuration (root project name: "Bookstore")
- `app/build.gradle.kts` - Application dependencies and build configuration
- `gradle/libs.versions.toml` - Centralized dependency version management
- `app/src/main/java/com/bookstore/main/Main.java` - Application entry point

## Dependencies and Technologies

### Core Dependencies
- **Guava 33.0.0-jre** - Google's core libraries for Java
- **MySQL Connector 8.0.33** - JDBC driver for MySQL database
- **JUnit Jupiter 5.10.2** - Testing framework
- **Spring Boot Starter Web** - REST API and web MVC framework
- **Spring Boot Starter Thymeleaf** - Server-side template engine
- **Bootstrap 5.3.2** - Frontend CSS framework
- **jQuery 3.7.1** - JavaScript library

### Database Configuration
- **Database**: `online_bookstore_db` on localhost:3306
- **Default Credentials**: root/12345678 (configured in `DBConnection.java`)
- **Connection**: JDBC with MySQL Connector/J driver

## Architecture Patterns

### Layered Architecture
- **Web Layer**: Spring Boot controllers for REST APIs and web pages
  - `web/api/` - REST API controllers (BookApiController, OrderApiController)
  - `web/controller/` - Web page controllers (BookstoreWebController)
- **Service Layer**: Business logic (OrderService) - **UNCHANGED**
- **Data Access Layer**: DAO pattern for database operations - **UNCHANGED**
- **Model Layer**: Plain Java objects (POJOs) for domain entities - **UNCHANGED**

### Design Patterns Used
- **DAO Pattern**: Separate data access logic from business logic
- **Queue Pattern**: OrderProcessingQueue for asynchronous order processing
- **Strategy Pattern**: Comparators for different sorting strategies

## Development Best Practices

### Code Organization
- Use package-by-feature organization under `com.bookstore`
- Separate concerns with distinct layers (model, dao, service, util)
- Follow Java naming conventions (PascalCase for classes, camelCase for methods/variables)

### Database Operations
- Use PreparedStatement for all SQL operations to prevent SQL injection
- Handle SQLException appropriately with meaningful error messages
- Use try-with-resources for automatic resource management
- Check for specific MySQL error codes (1062 for duplicates, 1451 for foreign key constraints)

### Error Handling
- Catch and handle specific exceptions (SQLException, ClassNotFoundException)
- Provide meaningful error messages to users
- Use proper logging instead of System.out.println in production code
- Validate input parameters before database operations

### Algorithm Implementation
- Custom sorting algorithms in `util/algorithms/SortingAlgorithms.java`
- Binary search implementation in `util/algorithms/SearchingAlgorithms.java`
- Use Comparator pattern for flexible sorting strategies

## Build and Development

### Gradle Commands
```bash
./gradlew build          # Build the project
./gradlew bootRun        # Run the web application (Spring Boot)
./gradlew run            # Run the console application (original Main class)
./gradlew test           # Run tests
./gradlew clean          # Clean build artifacts
```

### Running the Web Application
1. **Start the web server**: `./gradlew bootRun`
2. **Access the web interface**: http://localhost:8080
3. **API endpoints**: http://localhost:8080/api/

### Available Web Pages
- **Home**: `/` - Dashboard with book statistics and overview
- **Books Management**: `/books` - View, add, edit, delete books
- **Add Book**: `/books/add` - Form to add new books
- **Orders**: `/orders` - View and manage orders
- **Create Order**: `/orders/create` - Form to create new orders
- **Customers**: `/customers` - View customer information

### Available API Endpoints
- **Books API**: 
  - `GET /api/books` - Get all books
  - `GET /api/books/{id}` - Get book by ID
  - `POST /api/books` - Add new book
  - `PUT /api/books/{id}` - Update book
  - `DELETE /api/books/{id}` - Delete book
  - `PUT /api/books/{id}/stock?quantityChange=X` - Update stock
- **Orders API**:
  - `GET /api/orders` - Get all orders
  - `GET /api/orders/{id}` - Get order by ID
  - `POST /api/orders` - Create new order
  - `POST /api/orders/process-queue` - Process next order in queue
  - `GET /api/orders/queue/size` - Get queue size

### IDE Configuration
- VS Code settings configured for automatic Java build configuration updates
- Java toolchain set to version 21
- **Console Application**: Main class `com.bookstore.main.Main`
- **Web Application**: Main class `com.bookstore.BookstoreWebApplication`

## Database Setup Requirements

### Prerequisites
- MySQL server running on localhost:3306
- Database named `online_bookstore_db` must exist
- Required tables: Books, Customers, Orders, OrderItems
- Default credentials: root/12345678 (update in DBConnection.java as needed)

### Database Schema Considerations
- Books table with auto-increment book_id primary key
- Foreign key relationships between Orders and Customers
- Foreign key relationships between OrderItems and Books/Orders
- Stock quantity tracking in Books table

## Testing and Quality

### Testing Strategy
- JUnit Jupiter for unit testing
- Test database operations with proper setup/teardown
- Test business logic in service layer
- Test algorithm implementations separately

### Code Quality Guidelines
- Follow Java coding standards
- Use meaningful variable and method names
- Add proper JavaDoc comments for public APIs
- Handle edge cases (null checks, empty collections)
- Validate business rules (stock quantity, order totals)

## Common Development Tasks

### Adding New Features
1. Create model classes in `model/` package
2. Implement DAO classes for database operations
3. Add business logic in `service/` package
4. Update Main class to demonstrate new functionality
5. Add appropriate tests

### Database Schema Changes
1. Update SQL scripts for table modifications
2. Modify corresponding model classes
3. Update DAO methods for new fields
4. Test with existing data migration

### Algorithm Integration
1. Add new algorithms to `util/algorithms/` package
2. Create appropriate comparators for sorting
3. Integrate with service layer business logic
4. Add performance tests for large datasets

## Security Considerations

### Database Security
- **CRITICAL**: Change default database credentials in production
- Use environment variables or configuration files for sensitive data
- Implement proper connection pooling for production use
- Consider using prepared statements exclusively

### Input Validation
- Validate all user inputs before database operations
- Sanitize string inputs to prevent injection attacks
- Implement proper bounds checking for numeric inputs
- Use parameterized queries consistently

## Performance Considerations

### Database Performance
- Consider adding database indexes for frequently queried fields
- Implement connection pooling for better resource management
- Use batch operations for bulk inserts/updates
- Monitor query performance and optimize as needed

### Algorithm Performance
- Binary search requires sorted data - ensure proper sorting
- Consider caching frequently accessed data
- Profile algorithm performance with large datasets
- Use appropriate data structures for different use cases